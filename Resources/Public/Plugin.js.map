{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@neos-project+neos-ui-extensibility@8.3.11/node_modules/@neos-project/neos-ui-extensibility/src/readFromConsumerApi.ts", "../../node_modules/.pnpm/@neos-project+neos-ui-extensibility@8.3.11/node_modules/@neos-project/neos-ui-extensibility/src/shims/vendor/react/index.js", "../../node_modules/.pnpm/@neos-project+neos-ui-extensibility@8.3.11/node_modules/@neos-project/neos-ui-extensibility/src/shims/neosProjectPackages/neos-ui-decorators/index.js", "../../node_modules/.pnpm/@neos-project+neos-ui-extensibility@8.3.11/node_modules/@neos-project/neos-ui-extensibility/src/index.ts", "../Private/RangeEditor/Editor/index.jsx", "../../node_modules/.pnpm/use-debounce@10.0.4_react@18.3.1/node_modules/use-debounce/src/useDebouncedCallback.ts", "../../node_modules/.pnpm/use-debounce@10.0.4_react@18.3.1/node_modules/use-debounce/src/useDebounce.ts", "../../node_modules/.pnpm/use-debounce@10.0.4_react@18.3.1/node_modules/use-debounce/src/useThrottledCallback.ts", "../../node_modules/.pnpm/clsx@2.1.1/node_modules/clsx/dist/clsx.mjs", "../Private/RangeEditor/manifest.js"],
  "sourcesContent": [null, null, null, null, "import React, { useState, useEffect, useRef } from \"react\";\nimport { neos } from \"@neos-project/neos-ui-decorators\";\nimport { useDebounce } from \"use-debounce\";\nimport style from \"./style.module.css\";\nimport clsx from \"clsx\";\n\nconst neosifier = neos((globalRegistry) => ({\n    i18nRegistry: globalRegistry.get(\"i18n\"),\n    config: globalRegistry.get(\"frontendConfiguration\").get(\"Carbon.RangeEditor\"),\n}));\n\nconst defaultOptions = {\n    min: 0,\n    max: 100,\n    step: 1,\n    unit: \"\",\n    showMinLabel: true,\n    showMaxLabel: true,\n    minLabel: null,\n    maxLabel: null,\n    disabled: false,\n    showInput: true,\n    valueLabelsFile: \"\",\n    valueLabels: {},\n};\n\nfunction Editor({ value, id, highlight, i18nRegistry, onEnterKey, onKeyDown, onKeyPress, commit, ...props }) {\n    const forceUpdate = useForceUpdate();\n    const [state, setState] = useState(value);\n    const [debouncedState] = useDebounce(state, 500);\n    const options = { ...defaultOptions, ...props.options };\n    const ratioMode = options.ratio == true && options.unit == \"%\" && options.min >= 0 && options.max <= 100;\n    const textfieldRef = useRef(null);\n\n    const handleChange = (event) => {\n        changeValue(event.target.value);\n    };\n\n    useEffect(() => {\n        if (debouncedState != value) {\n            // Check if the value from the input field fits into the step settings\n            const { step, min } = options;\n            const number = parseFloat(debouncedState);\n            let addValue = step - ((number - min) % step);\n            if (addValue == 0 || addValue == step) {\n                addValue = 0;\n            }\n            if (addValue > step / 2) {\n                addValue = addValue - step;\n            }\n            const finalValue = Math.min(options.max, Math.max(options.min, number + addValue));\n            changeValue(finalValue);\n        }\n    }, [debouncedState]);\n\n    const changeValue = (value) => {\n        setState(value);\n        const useParseInt = (options.step || 1) % 1 === 0;\n        value = useParseInt ? parseInt(value, 10) : parseFloat(value, 10);\n        if (isNaN(value)) {\n            return;\n        }\n        value = Math.min(options.max, Math.max(options.min, value));\n        commit(value);\n\n        forceUpdate();\n    };\n\n    const handleKeyPress = (event) => {\n        if (typeof onKeyPress === \"function\") {\n            onKeyPress(event);\n        }\n\n        if (event.key === \"Enter\" && typeof onEnterKey === \"function\") {\n            onEnterKey();\n            return;\n        }\n    };\n\n    const handleKeyDown = (event) => {\n        if (typeof onKeyDown === \"function\") {\n            onKeyDown(event);\n        }\n\n        const key = event.key;\n        const isUp = key == \"ArrowUp\";\n        if (key == \"ArrowDown\" || isUp) {\n            let step = options.step;\n            const { metaKey, shiftKey } = event;\n            const multiplier = shiftKey ? 10 : metaKey ? 100 : 1;\n            step = step * multiplier;\n            if (isUp) {\n                changeValue(Math.min(value + step, options.max));\n                event.preventDefault();\n                return;\n            }\n            changeValue(Math.max(value - step, options.min));\n            event.preventDefault();\n            return;\n        }\n    };\n\n    const valueAsString = !value ? \"0\" : value;\n    // Calculate the width of the input field based on the length of the min, max and step values\n    const numLength = (value) => value.toString().length;\n    const additionalStepLength = numLength(options.step) - 1;\n    const styleWidth = Math.max(numLength(options.min), numLength(options.max)) + additionalStepLength + \"ch\";\n    const unit = options.unit ? i18nRegistry.translate(options.unit) : \"\";\n\n    const { valueLabels, valueLabelsFile, showInput } = options;\n    let showMiddle = between(value, options.min, options.max);\n    if (!options.showMinLabel) {\n        showMiddle = showMiddle || value === options.min;\n    }\n    if (!options.showMaxLabel) {\n        showMiddle = showMiddle || value === options.max;\n    }\n    const getValueLabel = (value) => {\n        if (valueLabels && valueLabels[value]) {\n            return valueLabels[value];\n        }\n        if (valueLabelsFile) {\n            return `${valueLabelsFile}:${value}`;\n        }\n        return null;\n    };\n\n    const getLabel = (value, ignoreShowInput) => {\n        if (value <= options.min) {\n            const fallback = !showInput || ignoreShowInput ? options.min + unit : null;\n            const label = options.minLabel || getValueLabel(options.min) || fallback;\n            return i18nRegistry.translate(label);\n        }\n        if (value >= options.max) {\n            const fallback = !showInput || ignoreShowInput ? options.max + unit : null;\n            const label = options.maxLabel || getValueLabel(options.max) || fallback;\n            return i18nRegistry.translate(label);\n        }\n        return i18nRegistry.translate(getValueLabel(value));\n    };\n\n    const currentLabel = getLabel(value);\n\n    return (\n        <div className={clsx(style.editor, options.disabled && style.editorDisabled)}>\n            <input\n                type=\"range\"\n                id={!ratioMode && !currentLabel && showInput ? null : id}\n                min={options.min}\n                max={options.max}\n                step={options.step}\n                value={valueAsString}\n                className={clsx(style.slider, highlight && style.sliderHighlight)}\n                onChange={handleChange}\n                onKeyDown={handleKeyDown}\n                onKeyPress={handleKeyPress}\n                disabled={options.disabled}\n            />\n            <div\n                className={clsx(\n                    style.editorValue,\n                    !options.showMinLabel && !options.showMaxLabel && style.editorValueSingle,\n                )}\n            >\n                {ratioMode ? (\n                    <>\n                        <button\n                            type=\"button\"\n                            title={i18nRegistry.translate(\"Neos.Neos.Ui:Main:rangeEditorMinimum\")}\n                            onClick={() => changeValue(options.min)}\n                            disabled={options.disabled}\n                        >\n                            {valueAsString}%\n                        </button>\n                        <button\n                            type=\"button\"\n                            title={i18nRegistry.translate(\"Neos.Neos.Ui:Main:rangeEditorMaximum\")}\n                            onClick={() => changeValue(options.max)}\n                            disabled={options.disabled}\n                        >\n                            {100 - value}%\n                        </button>\n                    </>\n                ) : (\n                    <>\n                        {options.showMinLabel && (\n                            <button\n                                type=\"button\"\n                                title={i18nRegistry.translate(\"Neos.Neos.Ui:Main:rangeEditorMinimum\")}\n                                onClick={() => changeValue(options.min)}\n                                style={{ opacity: !showInput && options.min >= value ? 1 : 0.7 }}\n                                disabled={options.disabled}\n                            >\n                                {getLabel(options.min, true)}\n                            </button>\n                        )}\n                        {!showMiddle && !showInput && <span>&nbsp;</span>}\n                        {currentLabel && showMiddle && <span className={style.valueLabel}>{currentLabel}</span>}\n                        {!currentLabel && showInput && (\n                            <span className={clsx(style.textfield, !!unit && unit.toString().startsWith(\" \") && style.textfieldGap)} onClick={() => {\n                                textfieldRef?.current?.focus();\n                            }}>\n                                <input\n                                    id={id}\n                                    title={i18nRegistry.translate(\"Neos.Neos.Ui:Main:rangeEditorCurrentValue\")}\n                                    type=\"text\"\n                                    onKeyDown={handleKeyDown}\n                                    onKeyPress={(event) => {\n                                        handleKeyPress(event);\n                                        if (isNaN(event.key)) {\n                                            event.preventDefault();\n                                        }\n                                    }}\n                                    onChange={(event) => setState(event.target.value)}\n                                    value={!state ? \"0\" : state}\n                                    style={{ width: styleWidth }}\n                                    disabled={options.disabled}\n                                    ref={textfieldRef}\n                                />\n                                {unit && <span>{unit.toString().trim()}</span>}\n                            </span>\n                        )}\n                        {!currentLabel && showMiddle && !showInput && (\n                            <span>\n                                {valueAsString}\n                                {unit}\n                            </span>\n                        )}\n                        {options.showMaxLabel && (\n                            <button\n                                type=\"button\"\n                                title={i18nRegistry.translate(\"Neos.Neos.Ui:Main:rangeEditorMaximum\")}\n                                onClick={() => changeValue(options.max)}\n                                style={{ opacity: !showInput && options.max <= value ? 1 : 0.7 }}\n                                disabled={options.disabled}\n                            >\n                                {getLabel(options.max, true)}\n                            </button>\n                        )}\n                    </>\n                )}\n            </div>\n        </div>\n    );\n}\n\n//create your forceUpdate hook\nfunction useForceUpdate() {\n    const [, setValue] = useState(0); // integer state\n    return () => setValue((value) => value + 1); // update state to force render\n    // A function that increment \uD83D\uDC46\uD83C\uDFFB the previous state like here\n    // is better than directly setting `setValue(value + 1)`\n}\n\nfunction between(x, min, max) {\n    return x > min && x < max;\n}\n\nexport default neosifier(Editor);\n", "import { useRef, useEffect, useMemo } from 'react';\n\nexport interface CallOptions {\n  /**\n   * Controls if the function should be invoked on the leading edge of the timeout.\n   */\n  leading?: boolean;\n  /**\n   * Controls if the function should be invoked on the trailing edge of the timeout.\n   */\n  trailing?: boolean;\n}\n\nexport interface Options extends CallOptions {\n  /**\n   * The maximum time the given function is allowed to be delayed before it's invoked.\n   */\n  maxWait?: number;\n  /**\n   * If the setting is set to true, all debouncing and timers will happen on the server side as well\n   */\n  debounceOnServer?: boolean;\n}\n\nexport interface ControlFunctions<ReturnT> {\n  /**\n   * Cancel pending function invocations\n   */\n  cancel: () => void;\n  /**\n   * Immediately invoke pending function invocations\n   */\n  flush: () => ReturnT | undefined;\n  /**\n   * Returns `true` if there are any pending function invocations\n   */\n  isPending: () => boolean;\n}\n\n/**\n * Subsequent calls to the debounced function return the result of the last func invocation.\n * Note, that if there are no previous invocations you will get undefined. You should check it in your code properly.\n */\nexport interface DebouncedState<T extends (...args: any) => ReturnType<T>>\n  extends ControlFunctions<ReturnType<T>> {\n  (...args: Parameters<T>): ReturnType<T> | undefined;\n}\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked, or until the next browser frame is drawn.\n *\n * The debounced function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the debounced function.\n *\n * Subsequent calls to the debounced function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `debounce` and `throttle`.\n *\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0]\n *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is\n *  used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n *  Controls if `func` should be invoked on the leading edge of the timeout.\n * @param {boolean} [options.leading=false]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {number} [options.maxWait]\n *  Controls if `func` should be invoked the trailing edge of the timeout.\n * @param {boolean} [options.trailing=true]\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * const resizeHandler = useDebouncedCallback(calculateLayout, 150);\n * window.addEventListener('resize', resizeHandler)\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * const clickHandler = useDebouncedCallback(sendMail, 300, {\n *   leading: true,\n *   trailing: false,\n * })\n * <button onClick={clickHandler}>click me</button>\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * const debounced = useDebouncedCallback(batchLog, 250, { 'maxWait': 1000 })\n * const source = new EventSource('/stream')\n * source.addEventListener('message', debounced)\n *\n * // Cancel the trailing debounced invocation.\n * window.addEventListener('popstate', debounced.cancel)\n *\n * // Check for pending invocations.\n * const status = debounced.pending() ? \"Pending...\" : \"Ready\"\n */\nexport default function useDebouncedCallback<\n  T extends (...args: any) => ReturnType<T>,\n>(func: T, wait?: number, options?: Options): DebouncedState<T> {\n  const lastCallTime = useRef(null);\n  const lastInvokeTime = useRef(0);\n  const timerId = useRef(null);\n  const lastArgs = useRef<unknown[]>([]);\n  const lastThis = useRef<unknown>();\n  const result = useRef<ReturnType<T>>();\n  const funcRef = useRef(func);\n  const mounted = useRef(true);\n  // Always keep the latest version of debounce callback, with no wait time.\n  funcRef.current = func;\n\n  const isClientSide = typeof window !== 'undefined';\n  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.\n  const useRAF = !wait && wait !== 0 && isClientSide;\n\n  if (typeof func !== 'function') {\n    throw new TypeError('Expected a function');\n  }\n\n  wait = +wait || 0;\n  options = options || {};\n\n  const leading = !!options.leading;\n  const trailing = 'trailing' in options ? !!options.trailing : true; // `true` by default\n  const maxing = 'maxWait' in options;\n  const debounceOnServer =\n    'debounceOnServer' in options ? !!options.debounceOnServer : false; // `false` by default\n  const maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : null;\n\n  useEffect(() => {\n    mounted.current = true;\n    return () => {\n      mounted.current = false;\n    };\n  }, []);\n\n  // You may have a question, why we have so many code under the useMemo definition.\n  //\n  // This was made as we want to escape from useCallback hell and\n  // not to initialize a number of functions each time useDebouncedCallback is called.\n  //\n  // It means that we have less garbage for our GC calls which improves performance.\n  // Also, it makes this library smaller.\n  //\n  // And the last reason, that the code without lots of useCallback with deps is easier to read.\n  // You have only one place for that.\n  const debounced = useMemo(() => {\n    const invokeFunc = (time: number) => {\n      const args = lastArgs.current;\n      const thisArg = lastThis.current;\n\n      lastArgs.current = lastThis.current = null;\n      lastInvokeTime.current = time;\n      return (result.current = funcRef.current.apply(thisArg, args));\n    };\n\n    const startTimer = (pendingFunc: () => void, wait: number) => {\n      if (useRAF) cancelAnimationFrame(timerId.current);\n      timerId.current = useRAF\n        ? requestAnimationFrame(pendingFunc)\n        : setTimeout(pendingFunc, wait);\n    };\n\n    const shouldInvoke = (time: number) => {\n      if (!mounted.current) return false;\n\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (\n        !lastCallTime.current ||\n        timeSinceLastCall >= wait ||\n        timeSinceLastCall < 0 ||\n        (maxing && timeSinceLastInvoke >= maxWait)\n      );\n    };\n\n    const trailingEdge = (time: number) => {\n      timerId.current = null;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs.current) {\n        return invokeFunc(time);\n      }\n      lastArgs.current = lastThis.current = null;\n      return result.current;\n    };\n\n    const timerExpired = () => {\n      const time = Date.now();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // https://github.com/xnimorz/use-debounce/issues/97\n      if (!mounted.current) {\n        return;\n      }\n      // Remaining wait calculation\n      const timeSinceLastCall = time - lastCallTime.current;\n      const timeSinceLastInvoke = time - lastInvokeTime.current;\n      const timeWaiting = wait - timeSinceLastCall;\n      const remainingWait = maxing\n        ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n\n      // Restart the timer\n      startTimer(timerExpired, remainingWait);\n    };\n\n    const func: DebouncedState<T> = (...args: Parameters<T>): ReturnType<T> => {\n      if (!isClientSide && !debounceOnServer) {\n        return;\n      }\n      const time = Date.now();\n      const isInvoking = shouldInvoke(time);\n\n      lastArgs.current = args;\n      lastThis.current = this;\n      lastCallTime.current = time;\n\n      if (isInvoking) {\n        if (!timerId.current && mounted.current) {\n          // Reset any `maxWait` timer.\n          lastInvokeTime.current = lastCallTime.current;\n          // Start the timer for the trailing edge.\n          startTimer(timerExpired, wait);\n          // Invoke the leading edge.\n          return leading ? invokeFunc(lastCallTime.current) : result.current;\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          startTimer(timerExpired, wait);\n          return invokeFunc(lastCallTime.current);\n        }\n      }\n      if (!timerId.current) {\n        startTimer(timerExpired, wait);\n      }\n      return result.current;\n    };\n\n    func.cancel = () => {\n      if (timerId.current) {\n        useRAF\n          ? cancelAnimationFrame(timerId.current)\n          : clearTimeout(timerId.current);\n      }\n      lastInvokeTime.current = 0;\n      lastArgs.current =\n        lastCallTime.current =\n        lastThis.current =\n        timerId.current =\n          null;\n    };\n\n    func.isPending = () => {\n      return !!timerId.current;\n    };\n\n    func.flush = () => {\n      return !timerId.current ? result.current : trailingEdge(Date.now());\n    };\n\n    return func;\n  }, [\n    leading,\n    maxing,\n    wait,\n    maxWait,\n    trailing,\n    useRAF,\n    isClientSide,\n    debounceOnServer,\n  ]);\n\n  return debounced;\n}\n", "import { useCallback, useRef, useState } from 'react';\nimport useDebouncedCallback, { DebouncedState } from './useDebouncedCallback';\n\nfunction valueEquality<T>(left: T, right: T): boolean {\n  return left === right;\n}\n\nexport default function useDebounce<T>(\n  value: T,\n  delay: number,\n  options?: {\n    maxWait?: number;\n    leading?: boolean;\n    trailing?: boolean;\n    equalityFn?: (left: T, right: T) => boolean;\n  }\n): [T, DebouncedState<(value: T) => void>] {\n  const eq = (options && options.equalityFn) || valueEquality;\n\n  const activeValue = useRef(value);\n  const [, forceUpdate] = useState({});\n  const debounced = useDebouncedCallback(\n    useCallback(\n      (value: T) => {\n        activeValue.current = value;\n        forceUpdate({});\n      },\n      [forceUpdate]\n    ),\n    delay,\n    options\n  );\n  const previousValue = useRef(value);\n\n  if (!eq(previousValue.current, value)) {\n    debounced(value);\n    previousValue.current = value;\n  }\n\n  return [activeValue.current as T, debounced];\n}\n", "import useDebouncedCallback, {\n  CallOptions,\n  DebouncedState,\n} from './useDebouncedCallback';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds (or once per browser frame).\n *\n * The throttled function comes with a `cancel` method to cancel delayed `func`\n * invocations and a `flush` method to immediately invoke them.\n *\n * Provide `options` to indicate whether `func` should be invoked on the leading\n * and/or trailing edge of the `wait` timeout. The `func` is invoked with the\n * last arguments provided to the throttled function.\n *\n * Subsequent calls to the throttled function return the result of the last\n * `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`\n * invocation will be deferred until the next frame is drawn (typically about\n * 16ms).\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `throttle` and `debounce`.\n *\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0]\n *  The number of milliseconds to throttle invocations to; if omitted,\n *  `requestAnimationFrame` is used (if available, otherwise it will be setTimeout(...,0)).\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * const scrollHandler = useThrottledCallback(updatePosition, 100)\n * window.addEventListener('scroll', scrollHandler)\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * const throttled = useThrottledCallback(renewToken, 300000, { 'trailing': false })\n * <button onClick={throttled}>click</button>\n *\n * // Cancel the trailing throttled invocation.\n * window.addEventListener('popstate', throttled.cancel);\n */\nexport default function useThrottledCallback<\n  T extends (...args: any) => ReturnType<T>,\n>(\n  func: T,\n  wait: number,\n  { leading = true, trailing = true }: CallOptions = {}\n): DebouncedState<T> {\n  return useDebouncedCallback(func, wait, {\n    maxWait: wait,\n    leading,\n    trailing,\n  });\n}\n", "function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;", "import manifest from \"@neos-project/neos-ui-extensibility\";\n\nimport Editor from \"./Editor\";\n\nmanifest(\"Carbon.RangeEditor:Editor\", {}, (globalRegistry) => {\n    const editorsRegistry = globalRegistry.get(\"inspector\").get(\"editors\");\n\n    editorsRegistry.set(\"Carbon.RangeEditor/Editor\", {\n        component: Editor,\n    });\n});\n"],
  "mappings": "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",
  "names": ["readFromConsumerApi", "key", "args", "init_readFromConsumerApi", "__esmMin", "require_react", "__commonJSMin", "exports", "module", "init_readFromConsumerApi", "readFromConsumerApi", "require_neos_ui_decorators", "__commonJSMin", "exports", "module", "init_readFromConsumerApi", "readFromConsumerApi", "init_readFromConsumerApi", "dist_default", "readFromConsumerApi", "import_react", "import_neos_ui_decorators", "useDebouncedCallback", "func", "wait", "options", "_this", "this", "lastCallTime", "useRef", "lastInvokeTime", "timerId", "lastArgs", "lastThis", "result", "funcRef", "mounted", "current", "isClientSide", "window", "useRAF", "TypeError", "leading", "trailing", "maxing", "debounceOnServer", "maxWait", "Math", "max", "useEffect", "debounced", "useMemo", "invokeFunc", "time", "args", "thisArg", "apply", "startTimer", "pendingFunc", "cancelAnimationFrame", "requestAnimationFrame", "setTimeout", "shouldInvoke", "timeSinceLastCall", "trailingEdge", "timerExpired", "Date", "now", "timeWaiting", "remainingWait", "min", "isInvoking", "slice", "call", "arguments", "cancel", "clearTimeout", "isPending", "flush", "valueEquality", "left", "right", "useDebounce", "value", "delay", "eq", "equalityFn", "activeValue", "forceUpdate", "useState", "useCallback", "previousValue", "r", "e", "t", "f", "n", "o", "clsx", "clsx_default", "neosifier", "globalRegistry", "defaultOptions", "Editor", "value", "id", "highlight", "i18nRegistry", "onEnterKey", "onKeyDown", "onKeyPress", "commit", "props", "forceUpdate", "useForceUpdate", "state", "setState", "debouncedState", "a", "options", "ratioMode", "textfieldRef", "handleChange", "event", "changeValue", "step", "min", "number", "addValue", "finalValue", "handleKeyPress", "handleKeyDown", "key", "isUp", "metaKey", "shiftKey", "valueAsString", "numLength", "additionalStepLength", "styleWidth", "unit", "valueLabels", "valueLabelsFile", "showInput", "showMiddle", "between", "getValueLabel", "getLabel", "ignoreShowInput", "fallback", "label", "currentLabel", "React", "clsx_default", "style_default", "setValue", "x", "max", "Editor_default", "dist_default", "globalRegistry", "Editor_default"]
}
